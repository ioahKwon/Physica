================================================================================
   AddB → SKEL 어깨 Joint Definition 불일치 문제 - ChatGPT 논의용 정리
================================================================================

1. 현재 상황
================================================================================

1.1 세 모델의 어깨 Joint Definition
--------------------------------------------------------------------------------

모델              | 어깨 Joint              | Index   | 위치 특성
------------------|-------------------------|---------|----------------------------------
AddBiomechanics   | acromial_r/l            | 12, 16  | 견봉(Acromion) - 어깨 가장 바깥쪽
SKEL              | scapula_r/l             | 14, 19  | 견갑골 - 척추에 가까움 (medial)
                  | humerus_r/l             | 15, 20  | 상완골 연결점 (GH joint)
SMPL              | right/left_shoulder     | 17, 16  | 단순화된 어깨 joint

1.2 현재 매핑 (skel_model.py)
--------------------------------------------------------------------------------
'acromial_r': 'humerus_r',  # AddB[12] → SKEL[15]
'acromial_l': 'humerus_l',  # AddB[16] → SKEL[20]

1.3 문제점
--------------------------------------------------------------------------------
- AddB의 acromial은 어깨 가장 바깥쪽 (견봉 = acromion process)
- SKEL의 humerus는 어깨-팔 연결점으로, acromial보다 안쪽(medial)에 위치
- 결과: SKEL이 "어좁이"처럼 어깨가 좁게 나옴
- MPJPE는 26.3mm로 좋지만, 시각적으로 어색함

================================================================================
2. 기술적 배경
================================================================================

2.1 SKEL Joint Regressor 구조
--------------------------------------------------------------------------------
파일: /SKEL/skel/skel_model.py

J = torch.einsum('bik,ji->bjk', [v_shaped, self.J_regressor_osim])

- v_shaped: [B, 6890, 3]       # mesh vertices
- J_regressor_osim: [24, 6890] # sparse weight matrix (각 row = 1개 joint)
- J: [B, 24, 3]                # output joint positions

각 joint position = vertex positions의 가중 합
joint_j = sum_v (regressor[j, v] * vertex[v])

2.2 Custom Joint Regressor 지원 (SKEL 내장 기능)
--------------------------------------------------------------------------------
if custom_joint_reg_path is not None:
    J_regressor_skel = pkl.load(open(custom_joint_reg_path, 'rb'))
    self.register_buffer('J_regressor_osim', torch.FloatTensor(J_regressor_skel))

→ [24, 6890] 대신 [26, 6890]으로 확장하여 새 joint 추가 가능

2.3 dJ (Joint Offset) Parameter
--------------------------------------------------------------------------------
# SKEL forward에서:
if dJ is not None:
    J = J + dJ  # [B, 24, 3] offset

→ 기존 joint에 offset을 더하여 위치 조정 가능

2.4 이전에 시도한 Virtual Shoulder (실패)
--------------------------------------------------------------------------------
def compute_virtual_shoulder_positions(skel_joints, alpha=0.65):
    # scapula와 humerus의 가중 평균
    virtual_shoulder_r = alpha * skel_joints[:, 14] + (1 - alpha) * skel_joints[:, 15]
    return virtual_shoulder_r, virtual_shoulder_l

결과: 팔 위치까지 이상해져서 revert함

================================================================================
3. 수정 가능한 코드 위치
================================================================================

| 파일                                              | 역할                    |
|---------------------------------------------------|-------------------------|
| /SKEL/skel/skel_model.py (lines 121-130, 323-328) | J_regressor 정의        |
| /Physica/AddB_to_SMPL/models/skel_model.py        | Joint mapping dictionary|
| /Physica/AddB_to_SMPL/compare_smpl_skel.py        | Optimization loop       |
| /SKEL/skel/joints_def.py                          | Joint curve definitions |

================================================================================
4. 가능한 해결 방안들
================================================================================

방안 1: Joint Regressor 확장 ★ Yufei 박사님 추천 ★
--------------------------------------------------------------------------------
개념: J_regressor에 새로운 row를 추가하여 "virtual acromial" joint 정의

현재: J_regressor_osim.shape = [24, 6890]
수정: J_regressor_osim.shape = [26, 6890]  # acromial_r, acromial_l 추가

새 row 정의 방법:
1. scapula vertex들 중 lateral(바깥쪽) vertex 찾기
2. humerus 주변 vertex 중 superior(위쪽) vertex 찾기
3. 이들의 가중 조합으로 acromial 위치 근사

장점:
- Mesh vertex 기반으로 정확한 위치 지정 가능
- Pose 변화에 따라 자연스럽게 움직임
- 한 번 정의하면 모든 프레임에 적용

단점:
- 적절한 vertex 선택 필요 (해부학 지식 필요)
- SKEL 모델 자체를 수정해야 함


방안 2: Post-hoc Virtual Marker (Loss에서만 처리)
--------------------------------------------------------------------------------
개념: 기존 joint는 유지하고, loss 계산 시에만 virtual position 사용

def compute_acromial_from_skel(joints, vertices):
    # Option A: Joint 가중 평균 (이전에 실패)
    acromial_r = w1 * joints[:, 14] + w2 * joints[:, 15]

    # Option B: Vertex 직접 사용 (새로운 시도)
    acromial_vertices = [v1, v2, v3, ...]  # 견봉 부근 vertex indices
    acromial_r = vertices[:, acromial_vertices].mean(dim=1)

    return acromial_r, acromial_l

장점:
- SKEL 모델 수정 없이 구현 가능
- 빠른 실험 가능

단점:
- 매번 계산 필요
- Joint 기반이면 이전 실패와 같은 문제 가능


방안 3: Offset 학습 (dJ parameter 활용)
--------------------------------------------------------------------------------
개념: SKEL의 dJ parameter로 humerus를 acromial 방향으로 shift

# Optimization 시:
dJ[:, 15, :] = offset_toward_lateral  # humerus_r → acromial_r 방향
dJ[:, 20, :] = offset_toward_lateral  # humerus_l → acromial_l 방향

장점:
- 기존 infrastructure 활용
- Per-subject offset 가능

단점:
- 기존 joint 위치가 변경됨 (팔 kinematics 영향 가능)
- Pose-dependent하지 않음


방안 4: Bone Direction + Width 제약 강화
--------------------------------------------------------------------------------
개념: Acromial 위치 대신, 어깨 방향과 너비를 제약

# 어깨 너비 제약
shoulder_width_skel = norm(humerus_r - humerus_l)
shoulder_width_addb = norm(acromial_r - acromial_l)
loss += lambda * (shoulder_width_skel - shoulder_width_addb)^2

# 어깨 방향 제약
dir_skel = normalize(thorax → humerus_r)
dir_addb = normalize(back → acromial_r)
loss += lambda * (1 - dot(dir_skel, dir_addb))

장점:
- Joint 정의 변경 없이 가능
- 기존 bone length loss 확장

단점:
- 간접적인 제약이라 완벽하지 않을 수 있음


방안 5: Hybrid - Regressor + Fine-tuning
--------------------------------------------------------------------------------
개념: 대략적인 acromial regressor 추가 + optimization에서 dJ로 미세 조정

Step 1: J_regressor에 approximate acromial 추가
Step 2: Optimization 시 dJ로 per-subject 미세 조정
Step 3: Bone length constraint로 일관성 유지

================================================================================
5. 내 추천
================================================================================

추천: 방안 1 (Joint Regressor 확장) + 방안 4 (Bone 제약 강화)

이유:
1. Yufei 박사님이 추천한 방법이며, 가장 근본적인 해결책
2. Mesh vertex 기반이라 pose 변화에 robust
3. 한 번 잘 정의하면 모든 sequence에 적용 가능
4. Bone 제약으로 추가 안정성 확보

구현 순서:
1. SKEL mesh에서 견봉(acromion) 부근 vertex 분석
2. Vertex weight 정의하여 새 regressor row 생성
3. J_regressor를 [26, 6890]으로 확장
4. Mapping 업데이트: acromial_r/l → new_joint_24/25
5. Bone length constraint 업데이트

================================================================================
6. ChatGPT와 논의할 질문들
================================================================================

1. Vertex 선택:
   - SKEL mesh에서 acromion에 해당하는 vertex를 어떻게 찾을 것인가?
   - Anatomical landmark database 참조?
   - scapula/humerus 주변 vertex 시각화 후 수동 선택?

2. Weight 설계:
   - 여러 vertex의 가중 평균을 어떻게 설계할 것인가?
   - 단순 평균 vs 거리 기반 가중치?
   - Pose-dependent weight가 필요한가?

3. 검증 방법:
   - 새로운 joint가 제대로 정의되었는지 어떻게 검증?
   - AddB acromial과의 거리 비교?
   - 다양한 pose에서 visual inspection?

4. Alternative 접근:
   - Joint regressor 대신 다른 방법이 더 나을 수 있는가?
   - SMPL2AddBiomechanics repo에서 비슷한 문제를 어떻게 해결했는가?

================================================================================
7. 참고: SKEL 24개 Joint 목록
================================================================================

Index | Joint Name    | 설명
------|---------------|------------------
0     | pelvis        | 골반
1     | femur_r       | 오른쪽 고관절
2     | tibia_r       | 오른쪽 무릎
3     | talus_r       | 오른쪽 발목
4     | calcn_r       | 오른쪽 뒤꿈치
5     | toes_r        | 오른쪽 발가락
6     | femur_l       | 왼쪽 고관절
7     | tibia_l       | 왼쪽 무릎
8     | talus_l       | 왼쪽 발목
9     | calcn_l       | 왼쪽 뒤꿈치
10    | toes_l        | 왼쪽 발가락
11    | lumbar        | 요추
12    | thorax        | 흉추
13    | head          | 머리
14    | scapula_r     | 오른쪽 견갑골 ← 척추에 가까움
15    | humerus_r     | 오른쪽 상완골 ← 현재 acromial 매핑됨
16    | ulna_r        | 오른쪽 팔꿈치
17    | radius_r      | 오른쪽 전완
18    | hand_r        | 오른쪽 손
19    | scapula_l     | 왼쪽 견갑골
20    | humerus_l     | 왼쪽 상완골
21    | ulna_l        | 왼쪽 팔꿈치
22    | radius_l      | 왼쪽 전완
23    | hand_l        | 왼쪽 손

================================================================================
8. 참고: AddBiomechanics 20개 Joint 목록
================================================================================

Index | Joint Name    | 설명
------|---------------|------------------
0     | pelvis        | 골반
1     | femur_r       | 오른쪽 대퇴골
2     | tibia_r       | 오른쪽 경골
3     | talus_r       | 오른쪽 거골
4     | calcn_r       | 오른쪽 종골
5     | toes_r        | 오른쪽 발가락
6     | femur_l       | 왼쪽 대퇴골
7     | tibia_l       | 왼쪽 경골
8     | talus_l       | 왼쪽 거골
9     | calcn_l       | 왼쪽 종골
10    | toes_l        | 왼쪽 발가락
11    | torso         | 상체 (lumbar)
12    | acromial_r    | 오른쪽 견봉 ← 어깨 가장 바깥쪽!
13    | elbow_r       | 오른쪽 팔꿈치
14    | radius_r      | 오른쪽 손목
15    | hand_r        | 오른쪽 손
16    | acromial_l    | 왼쪽 견봉
17    | elbow_l       | 왼쪽 팔꿈치
18    | radius_l      | 왼쪽 손목
19    | hand_l        | 왼쪽 손

================================================================================
